contract DateTime =
 /*
  Date and Time utilities for sophia contracts
 */

 record buff = {month : int,
                day : int,
                seconds_accounted_for : int
                }

 record date_time = {year : int,
                     month : int,
                     day : int,
                     hour : int,
                     minute : int,
                     second : int,
                     weekday : int
                     }

 record state = {origin_year : int, 
                 day_in_seconds : int,
                 year_in_seconds : int,
                 leap_year_in_seconds : int,
                 hour_in_seconds : int,
                 minute_in_seconds : int
                 }
                 
                   
 public function init() : state =
   {origin_year = 1970, 
    day_in_seconds = 86400,
    year_in_seconds = 31536000,
    leap_year_in_seconds = 31622400,
    hour_in_seconds = 3600,
    minute_in_seconds = 60
    }

 private function init_date_time() : date_time =
   {year = 0,
    month = 0,
    day = 0,
    hour = 0,
    minute = 0,
    second = 0,
    weekday = 0
    }

 private function init_buff(m : int, saf : int) : buff = 
   {month = m,
    day = 0,
    seconds_accounted_for = saf
    }

 public function parse_timestamp(timestamp : int) : date_time =
   // init datetime structure
   let date_time = init_date_time()
   
   // year
   let date_time = date_time{year = get_year(timestamp)}

   let total_leap_years_before = leap_year_before(date_time.year) - leap_year_before(state.origin_year)

   let temp_seconds_accounted_for = state.leap_year_in_seconds * total_leap_years_before
   let temp_seconds_accounted_for = temp_seconds_accounted_for + state.year_in_seconds*(date_time.year - state.origin_year - total_leap_years_before)

   // init buff structure
   let buff = init_buff(0, temp_seconds_accounted_for)
   
   // month
   let month = p_get_month(timestamp, buff, date_time)
   let buff = buff{month = month}
   let date_time = date_time{month = buff.month}

   // day
   let buff = p_get_day(buff, date_time.year, timestamp)
   let date_time = date_time{day = buff.day}
   
   // hour
   let date_time = date_time{hour = get_hour(timestamp)}
   
   // minute
   let date_time = date_time{minute = get_minute(timestamp)}
   
   // second
   let date_time = date_time{second = 12345678910} //get_second(timestamp)}
   
   // weekday
   let date_time = date_time{weekday = get_weekday(timestamp)}
   date_time

 public function get_year(timestamp : int) : int = 
   let year = state.origin_year + timestamp/state.year_in_seconds
   let num_leap_years = leap_year_before(year) - leap_year_before(state.origin_year)
   
   let seconds_accounted_for = state.leap_year_in_seconds*num_leap_years
   let seconds_accounted_for = seconds_accounted_for + state.year_in_seconds*(year-state.origin_year - num_leap_years)
  
   get_year'(seconds_accounted_for, timestamp, year)

 public function get_month(timestamp : int) : int = 
   parse_timestamp(timestamp).month

 public function get_day(timestamp : int) : int = 
   parse_timestamp(timestamp).day

 public function get_hour(timestamp : int) : int = 
   rest(timestamp / 60 /60, 24)

 public function get_minute(timestamp : int) : int =
   rest(timestamp / 60, 60)

 public function get_second(timestamp : int) : int =
   rest(timestamp, 60)

 public function get_weekday(timestamp : int) : int = 
   rest(timestamp / state.day_in_seconds + 4, 7)

 private function get_year'(seconds_accounted_for : int, timestamp : int, year : int) : int =
   if(seconds_accounted_for > timestamp)
     let seconds_accounted_for =
       if(is_leap_year(year-1))
         seconds_accounted_for - state.leap_year_in_seconds
       else
         seconds_accounted_for - state.year_in_seconds
     get_year'(seconds_accounted_for,  timestamp, year - 1)
   else
     year

 private function p_get_month(timestamp, buff, date_time) = 
   let year = date_time.year
   let buf = leap_year_before(year) - leap_year_before(state.origin_year)
   p_get_month'(1, 12, get_year(timestamp), timestamp, buff.seconds_accounted_for)

 private function p_get_month'(begin, end, year, timestamp, seconds_accounted_for) =
   let seconds_in_month = state.day_in_seconds * get_days_in_month(begin, year)
   if((begin >= end) || (seconds_in_month + seconds_accounted_for > timestamp))
     begin
   else
     p_get_month'(begin + 1, end, year, timestamp, seconds_accounted_for + seconds_in_month)

 private function p_get_day(buff, year, timestamp) =
   p_get_day'(1, get_days_in_month(buff.month, year), buff, timestamp)

 private function p_get_day'(from, to, buff, timestamp) =
   if((from =< to) || (state.day_in_seconds + buff.seconds_accounted_for > timestamp))
     let buff = buff{day = from}
     buff
   else
     let buff = buff{seconds_accounted_for = buff.seconds_accounted_for + state.day_in_seconds}
     p_get_day'(from + 1, to, buff, timestamp)
   
 private function leap_year_before(year : int) : int =
   let year = year - 1
   year/4 - year/100 + year/400
   
 private function is_leap_year(year : int) : bool =
   if(rest(year, 4) != 0)
     false
   elif(rest(year, 100) != 0)
     true
   elif(rest(year, 400) != 0)
     false
   else
     true   

 private function get_days_in_month(month : int, year : int) : int =
   if(month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || 
      month == 10 || month == 12) 
     31
   elif (month == 4 || month == 6 || month == 9 || month == 11) 
     30
   elif(is_leap_year(year)) 
     29
   else 28

 private function rest(year : int, div : int) : int =
   year - div*(year/div)